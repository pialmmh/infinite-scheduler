package com.telcobright.scheduler.entity;

import com.telcobright.core.annotation.*;
import com.telcobright.scheduler.SchedulableEntity;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

/**
 * Generic entity that wraps a Map for any schedulable job.
 * This allows split-verse to work with ANY job type without compile-time entity knowledge.
 */
@Table(name = "scheduled_jobs")
public class GenericSchedulableEntity implements SchedulableEntity {

    private static final Logger logger = LoggerFactory.getLogger(GenericSchedulableEntity.class);

    @Id(autoGenerated = false)
    @Column(name = "id")
    private String id;

    @ShardingKey
    @Column(name = "scheduled_time")
    private LocalDateTime scheduledTime;

    @Column(name = "scheduled")
    private Boolean scheduled;

    @Column(name = "job_data")
    private String jobDataJson;  // JSON serialized Map<String, Object>

    @Column(name = "app_name")
    private String appName;

    @Column(name = "job_name")
    private String jobName;

    @Column(name = "created_at")
    private LocalDateTime createdAt;

    // Transient - not stored in DB
    private transient Map<String, Object> jobData;

    // Static Gson instance to avoid transient initialization issues
    private static final Gson GSON = new Gson();

    public GenericSchedulableEntity() {
        this.id = UUID.randomUUID().toString();
        this.jobData = new HashMap<>();
        this.scheduled = false;
        this.createdAt = LocalDateTime.now();
    }

    public GenericSchedulableEntity(String appName, Map<String, Object> jobData) {
        this.id = UUID.randomUUID().toString();
        this.appName = appName;
        this.jobData = jobData;
        this.scheduled = false;
        this.createdAt = LocalDateTime.now();

        // Extract scheduled time from map
        if (jobData.containsKey("scheduledTime")) {
            Object scheduledTimeObj = jobData.get("scheduledTime");
            if (scheduledTimeObj instanceof LocalDateTime) {
                this.scheduledTime = (LocalDateTime) scheduledTimeObj;
            } else {
                this.scheduledTime = LocalDateTime.parse(scheduledTimeObj.toString());
            }
        }

        // Extract job name if provided
        if (jobData.containsKey("jobName")) {
            this.jobName = jobData.get("jobName").toString();
        } else {
            this.jobName = "job-" + this.id;
        }

        // Create a copy of jobData with LocalDateTime converted to String for JSON serialization
        Map<String, Object> serializableData = new HashMap<>();
        for (Map.Entry<String, Object> entry : jobData.entrySet()) {
            if (entry.getValue() instanceof LocalDateTime) {
                serializableData.put(entry.getKey(), entry.getValue().toString());
            } else {
                serializableData.put(entry.getKey(), entry.getValue());
            }
        }

        // Serialize map to JSON
        this.jobDataJson = GSON.toJson(serializableData);
    }

    public Map<String, Object> getJobData() {
        logger.debug("getJobData called: jobData={}, jobDataJson={}", jobData, jobDataJson);
        if (jobData == null && jobDataJson != null) {
            logger.debug("Deserializing jobDataJson...");
            jobData = GSON.fromJson(jobDataJson,
                new TypeToken<Map<String, Object>>(){}.getType());
            logger.debug("Deserialized jobData with {} entries", jobData != null ? jobData.size() : 0);
        }
        Map<String, Object> result = jobData != null ? jobData : new HashMap<>();
        logger.debug("Returning jobData with size={}, keys={}", result.size(), result.keySet());
        return result;
    }

    public void setJobData(Map<String, Object> jobData) {
        this.jobData = jobData;
        this.jobDataJson = GSON.toJson(jobData);
    }

    @Override
    public String getId() {
        return id;
    }

    @Override
    public void setId(String id) {
        this.id = id;
    }

    @Override
    public LocalDateTime getScheduledTime() {
        return scheduledTime;
    }

    @Override
    public void setScheduledTime(LocalDateTime scheduledTime) {
        this.scheduledTime = scheduledTime;
    }

    @Override
    public Boolean getScheduled() {
        return scheduled;
    }

    @Override
    public void setScheduled(Boolean scheduled) {
        this.scheduled = scheduled;
    }

    @Override
    public LocalDateTime getPartitionColValue() {
        return scheduledTime;
    }

    @Override
    public void setPartitionColValue(LocalDateTime value) {
        this.scheduledTime = value;
    }

    @Override
    public String getJobId() {
        return jobName != null ? jobName : "job-" + id + "-" + scheduledTime;
    }

    public String getAppName() {
        return appName;
    }

    public void setAppName(String appName) {
        this.appName = appName;
    }

    public String getJobName() {
        return jobName;
    }

    public void setJobName(String jobName) {
        this.jobName = jobName;
    }

    public String getJobDataJson() {
        return jobDataJson;
    }

    public void setJobDataJson(String jobDataJson) {
        this.jobDataJson = jobDataJson;
        this.jobData = null; // Reset cache
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    @Override
    public String toString() {
        return "GenericSchedulableEntity{" +
                "id='" + id + '\'' +
                ", appName='" + appName + '\'' +
                ", jobName='" + jobName + '\'' +
                ", scheduledTime=" + scheduledTime +
                ", scheduled=" + scheduled +
                ", jobData=" + getJobData() +
                '}';
    }
}