package com.telcobright.scheduler.examples;

import com.telcobright.scheduler.InfiniteScheduler;
import com.telcobright.scheduler.SchedulerConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public class SchedulerExample {
    
    private static final Logger logger = LoggerFactory.getLogger(SchedulerExample.class);
    
    public static void main(String[] args) {
        try {
            smsSchedulerExample();
        } catch (Exception e) {
            logger.error("Error running scheduler examples", e);
        }
    }
    
    public static void smsSchedulerExample() throws Exception {
        logger.info("=== SMS Scheduler Example ===");
        
        SchedulerConfig config = SchedulerConfig.builder()
            .fetchInterval(30)              // Fetch every 30 seconds
            .lookaheadWindow(360)           // Look 6 minutes ahead (to capture all 5 jobs)
            .mysqlHost("127.0.0.1")         // MySQL host
            .mysqlPort(3306)               // MySQL port (default: 3306)
            .mysqlDatabase("scheduler")     // Database name (used for both Quartz and partitioned-repo)
            .mysqlUsername("root")          // MySQL username
            .mysqlPassword("123456")        // MySQL password
            .repositoryDatabase("scheduler") // Repository database (same as main database)
            .repositoryTablePrefix("sms")   // Repository table prefix
            .maxJobsPerFetch(10000)        // Process up to 10K jobs per fetch
            .autoCreateTables(true)        // Auto-create Quartz tables
            .autoCleanupCompletedJobs(true) // Auto-cleanup completed jobs
            .cleanupIntervalMinutes(30)    // Cleanup every 30 minutes
            .build();
        
        // Create scheduler with complete config - repository is created and managed internally
        InfiniteScheduler<SmsEntity, Long> scheduler = 
            new InfiniteScheduler<>(SmsEntity.class, Long.class, config, SmsJob.class);
        
        // Create dummy SMS jobs to be executed in the next 5 minutes
        createDummySmsJobs(scheduler);
        
        scheduler.start();
        
        logger.info("SMS Scheduler started. Press Ctrl+C to stop.");
        
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            try {
                logger.info("Shutting down SMS scheduler...");
                scheduler.stop();
            } catch (Exception e) {
                logger.error("Error stopping scheduler", e);
            }
        }));
        
        // Keep running for 10 minutes to see the jobs execute
        Thread.sleep(6000000); // 10 minutes
        scheduler.stop();
    }
    
    private static void createDummySmsJobs(InfiniteScheduler<SmsEntity, Long> scheduler) {
        logger.info("Creating 5 dummy SMS jobs for next 5 minutes...");
        
        LocalDateTime now = LocalDateTime.now();
        List<SmsEntity> dummyJobs = new ArrayList<>();
        
        // Create exactly 5 SMS jobs: 1 job per minute over next 5 minutes
        String[] phoneNumbers = {
            "+1234567890", "+1234567891", "+1234567892", "+1234567893", "+1234567894"
        };
        
        String[] messages = {
            "Hello! This is test SMS #1",
            "Welcome to our service! SMS #2", 
            "Order confirmed. SMS #3",
            "Appointment reminder. SMS #4",
            "Thank you for purchase! SMS #5"
        };
        
        for (int i = 0; i < 5; i++) {
            // Schedule jobs: 1 minute apart over next 5 minutes
            LocalDateTime scheduledTime = now.plusMinutes(i + 1); // 1min, 2min, 3min, 4min, 5min
            
            SmsEntity smsEntity = new SmsEntity();
            smsEntity.setId((long) (i + 1));
            // jobId is automatically generated by SchedulableEntity interface
            smsEntity.setPhoneNumber(phoneNumbers[i]);
            smsEntity.setMessage(messages[i]);
            smsEntity.setStatus("PENDING");
            smsEntity.setScheduled(false); // Not yet scheduled to Quartz
            smsEntity.setScheduledTime(scheduledTime); // Used as sharding key
            
            dummyJobs.add(smsEntity);
            
            logger.info("Created SMS job #{}: {} -> '{}' scheduled at {}", 
                i + 1, phoneNumbers[i], messages[i], scheduledTime);
        }
        
        // Insert all dummy jobs to the repository
        try {
            for (SmsEntity entity : dummyJobs) {
                scheduler.getRepository().insert(entity);
            }
            logger.info("Successfully inserted {} dummy SMS jobs to repository", dummyJobs.size());
            logger.info("Jobs scheduled: 1 job per minute over next 5 minutes");
            logger.info("Execution schedule: {} to {} (1-minute intervals)", 
                now.plusMinutes(1), now.plusMinutes(5));
        } catch (Exception e) {
            logger.error("Failed to insert dummy SMS jobs", e);
        }
    }
}